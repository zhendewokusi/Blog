---
title: TCP服务连接
date: 2023-10-25 13:10:42
tags: [TCP]
---

### TCP的建立与终止

#### 四元组

四元组通常指的是计算机网络中用于唯一标识一个网络连接的四个关键信息，包括：

1. **源IP地址**：这是连接发起方（通常是客户端）的IP地址。

2. **源端口号**：这是连接发起方的端口号。

3. **目标IP地址**：这是连接的目标（通常是服务器）的IP地址。

4. **目标端口号**：这是连接的目标的端口号。

#### 初始序列号

TCP报文段在经过网络后到达目标端口的次序是乱序的且存在延迟。TCP提出了序列号的概念，且在TCP的三次握手中互相得知对方正确的序列号，但是初始序列号的选择也有讲究。为防止出现与其他连接的序列号重叠的情况。

还有一种情况，一个四元组，因为网络的波动，某个报文段长延迟导致连接关闭，而后又用相同的四元组重新连接，网络中延迟的报文段又被接收端视作有效数据重新接收。这太可怕了，需要一种措施来避免序列号重叠的问题。

现代系统采用**半随机**的方法来初始化序列号，生成的序列号很难才出来。除了让序列号或者临时端口变得难猜出来，也可以使用加密来实现上述功能。

#### TCP的脆弱性
如果有合适的序列号、IP地址、端口号，任何人都可以伪造出一个TCP报文段，从而打断TCP的正常连接。



#### TCP连接

一个TCP连接由一个四元组构成，分为三个步骤：启动、数据传输、退出。

##### 启动

建立一个TCP连接，包含下面几个步骤：

1. 发送请求者（通常是客户端）给接收者发送 `SYN` 报文段，内包含自己想要连接的端口号，客户端的初始序列号 `ISN` 以及一些选项。

2. 服务端接收到 `SYN` 报文段后，它会回应一个 `SYN + ACK` 报文段，`SYN` 内包含服务端的初始序列号 `ISN`，而 `ACK` 用于确认客户端的初始序列号（`ISN`）已经成功接收，因此它的值是客户端的 `ISN + 1`。

3. 客户端接收到 `SYN + ACK` 报文段后，会发送一个 `ACK` 报文段，这个 `ACK` 报文段内包含了服务端的初始序列号 `ISN`（因为它已经在 `SYN` 中确认过），以及确认号（`ACK`）用于确认服务端的初始序列号已经成功接收。通常，`ACK` 序列号的值是服务端的 `ISN + 1`。

这是传统的TCP三次握手的过程，它确保连接的可靠建立。在这个过程中，`SYN` 报文段用于同步连接，而 `ACK` 报文段用于确认已接收的数据。这个过程确保了双方都知道彼此的初始序列号，并已经建立了双向的通信通道。

###### 三次握手的目的

- 让通信双方了解一个连接正在建立
- 利用数据包的选项来承载一些特殊信息
- 交换初始序列号

###### 三次握手分别失败的处理

1. 第一次握手失败：客户端发送 `SYN` 报文段后，如果服务器没有收到或者没有正确响应，客户端可能会重新发送 `SYN` 报文段。这是因为 TCP 是面向连接的，如果没有得到响应，客户端通常会尝试重新建立连接。

2. 第二次握手失败：如果服务器收到了客户端的 `SYN` 报文段并回应了 `SYN + ACK` 报文段，但客户端没有正确接收或响应，服务器可能会重新发送 `SYN + ACK` 报文段。服务器通常会在一定时间内等待客户端的确认，如果没有得到，它可能会认为连接失败并关闭。

3. 第三次握手失败：如果客户端收到了服务器的 `SYN + ACK` 报文段但没有正确确认，服务器可能会等待一段时间以等待客户端的 `ACK` 报文段。如果在一定时间内没有得到客户端的确认，服务器可能会关闭连接。

##### 数据传输


##### 退出

任何一方都可以发起退出操作。但是通常是又客户端发起的，也不排除有服务器处理完相应业务后主动发起退出。通常一个关闭操作是由应用程序发出的（比如系统调用close()）。只有双方都完成关闭操作后，才构成一个完整的关闭。当然也支持双方同时关闭连接的操作，比较少见。

关闭一个TCP连接通常需要4个报文段，也就是TCP的四次挥手：

1. 主动断开连接的一方（通常是客户端）向被动断开连接的一方（通常是服务器）发送包含`FIN`标志的TCP报文，其中包含了自己当前的序列号（M）。这通知被动方，客户端不再发送数据，但仍然愿意接收来自服务器的数据。此时，服务器仍然可以向客户端发送数据。

2. 被动断开连接的一方（通常是服务器）接收到包含`FIN`标志的报文后，将M + 1作为确认号（ACK）发送给主动断开连接的一方（客户端），表示已成功接收`FIN`报文，确认接收并停止主动发送数据，但仍然允许被动接收数据。此时，客户端也可以继续向服务器发送数据。

在第一步和第二步之后，连接仍然是打开的，允许双方接收数据。真正的连接终止发生在第三和第四步：

3. 被动方（服务器）转变成主动方，向主动断开连接的一方（客户端）发送包含`FIN`标志的TCP报文，其中包含自己当前的序列号（N）。这通知客户端，服务器不再发送数据，但仍然愿意接收来自客户端的数据。

4. 客户端接收到包含`FIN`标志的报文后，发送`ACK`以进行确认。此时，客户端也停止发送数据，连接完全关闭。服务器收到客户端的`ACK`后，连接也完全关闭。

所以，连接的关闭是逐步的，第三步和第四步后，双方都不再允许被动接收数据，连接处于完全关闭状态。在第一步和第二步之后，仍然允许被动接收数据，这使得双方有机会完成未完成的数据传输或处理挂起的请求。

###### 退出需要发送序列号的目的

确保对方正确接收到关闭请求（FIN报文）和在关闭连接的过程中保持数据的有序传输。这有助于防止数据包的丢失和乱序传输，从而确保连接的可靠关闭。

###### TCP半关闭

TCP是支持半关闭的。在TCP半关闭的操作中，连接的一个方向被关闭，另一个方向仍在传输数据直到它被关闭为止。应用程序只需要使用`shutdown()`来代替 `close()` 就可以了。通信的任何一方都可以发起半关闭操作。

实现这个操作并不难，和TCP的关闭的前两个步骤相同，主动发起半关闭的端口在执行完这两步操作后就不能主动发送数据了，而被动发起半关闭的端口依旧可以发送数据，主动发起半关闭的端口需要对数据进行`ACK`报文段发送确认。被动发起半关闭的端口发送完数据后，执行TCP关闭的后两步，就实现了TCP的半关闭。

##### 同时打开与关闭

没错，同时打开和关闭是可以在特点情况下实现的。通信双方在接收到对方的`SYN`之前必须发送一个`SYN`；两个`SYN`必须通过网络送达对方。该场景要求双方必须有 IP 和端口号，并且要告诉对方。这种很极限的情况下，就可以成为同时打开。

比如主机A的一个应用程序通过本地6666端口向主机B的本地8888端口发送TCP连接请求，而主机B的应用程序在本地的8888端口向主机A的本地6666端口发送TCP连接请求，这就可以称为**同时打开**。而主机A的一个客户端向主机B的一个服务器发送TCP连接请求，同时有主机B的一个客户端向主机A的一个服务器发送TCP连接请求，这不能成为同时打开，因为实质上是进行了两次互不相干的TCP连接，服务器始终是连接的被动打开者而不是主动打开者，各自的客户端也会选择不同的端口。

同时打开交换了4个报文段，比三次握手多了一次。而由于是双方同时发送请求的，也就没有客户端和服务端的区分。双方分别发送`SYN`报文段，分别接收到对方的`SYN`报文段，分别回复`SYN-ACK`。同时关闭过程和同时打开基本上原理一致。










