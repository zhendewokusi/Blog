---
title: TCP的服务模型
date: 2023-10-25 08:24:28
tags:   [TCP]
---

<!-- #### 拥塞控制

当发送方和接收方均没有受到它们其中任意一个`ACK`之外，允许发送方注入W个分组到网络。如果发送方和接收方足够快，网络没有丢失分组以及空间无限（理想情况），这就意味着通讯速率正比于窗口大小，分组大小，反比于往返时间。**当来自接收方的窗口通告夹带发送方的值W时，那么发送方的全部速率就被限制而不能超越接收方**。这样发送方和接收方的速率问题解决了，那么中间的网络呢？如果它两之间有一个会有限制内存的路由器，路由器和底层的链路层进行交互，如果发送方的速率可能超过某个路由器的能力，就会导致**丢包**。

**拥塞控制**涉及发送方降低速率以不至于压垮其与接收方的网络 -->

### TCP的服务模型

虽然`TCP`和`UDP`一样都在网络层，但是`TCP`给应用程序提供了一种不同于`UDP`的服务。`TCP`提供了一种**面向连接**、**可靠的字节流**服务。

#### 面向连接

`TCP`没有组播和广播的概念。面向连接是指两个基于`TCP`协议的应用程序必须在它们交换数据前，通过相互联系来建立一个`TCP`连接。

#### 可靠的字节流

`TCP`提供一种字节流抽象概念给应用程序。没有由TCP自动插入的消息边界：比如发送方一次写入10字节，随后20字节，50字节，而接收方可能是分四次读取这80字节。每个端点会独立的选择自己的读和写的大小。

`TCP`不会读取字节流内的字节内容。它甚至不清楚交换的字节流是ASCII码还是二进制码。

### TCP中的可靠性

1. 提供一个字节流接口，`TCP`必须把一个发送应用程序的字节流转换成一组IP可以携带的分组。这就是**组包**。这些分组包含序列号，该序列号在`TCP`中实际代表了每个分组的第一个字节相对于整个数据流的字节偏移，而不是分组号。这就允许了分组在传送中的大小是可变的，并且允许它们组合，这就是**重新组包**。字节流会被分散成`TCP`认为最佳大小的块来发送。
2. 提供了**强制的校验和**。该校验和涉及头部、传输数据、IP头部的所有字段。这是一个端对端的伪头部，用于检测传输过程中引入的比特差错。如果一个带无效校验和的报文段到达，`TCP`就会抛弃它，并且不会对发送方发送任何确认。然而，TCP接收端可能会对一个已经接受的报文段发送确认，用来帮助发送方计算它的**拥塞控制**。该校验和对于大数据传输的安全性其实不能完全保证，因此用户程序在发送大文件时最后自己实现一个差错保护的方法。
3. 发送一组报文段时，设置一个重传计时器。`TCP`不会为每个报文段设置一个重传计时器，而是给发送一个窗口的数据设置一个重传计时器，当有ACK到达时更新超时。如果有一个确认没有及时收到，这个报文段就会被重传。
4. 接收方会发送一个确认。这个确认会延迟一段时间发送。`TCP`使用的ACK是累积的，一个指示字节号为n的ACK暗示着所有知道n的字节已经被成功接收。这也可能会带来一个问题，如果中间有一个ACK没有收到，但是后续的ACK确认了前面的报文段。
5. 提供**双工服务**。也就是数据可以双向流动且互相独立。因此每个端点必须为每个方向维持数据流的字节号。在建立连接的基础上，这个连接的一个方向上的包含数据流的每个`TCP`报文段也包含相反方向上的报文段的一个ACK。每个报文段也包含一个窗口通告用来实现相反方向的流量控制。
6. 使用序列号。首先明确`TCP`是基于`IP`协议，而`IP`协议是不会消除重复的数据，也不会提供重传机制。`TCP`是一个字节流的协议，断然传输的数据是有顺序的。接收方可能会被迫先保持大序列号的数据不交给应用程序，知道小序列号的报文段被填满。

### TCP的头部和封装

TCP在IP数据报中的封装：

| IP头部协议（IPV4）或下一个头部(IPV6) | TCP头部 | 应用程序的数据 |
| ------------------------------------ | ------- | -------------- |

默认不带TCP选项的IP头部是20字节。带选项最大可以有60字节。选项包含：最大段大小、时间戳、窗口缩放、选择性ACK。

源端口 16 目的端口 16 
序列号 32 
确认号 32
头部长度 4 保留0 4 选项 8 窗口大小 16
TCP校验和 16 紧急指针 16 






